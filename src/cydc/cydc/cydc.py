#
# MIT License
#
# Copyright (c) 2024 Sergio Chico
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

from __future__ import print_function
from operator import itemgetter, attrgetter

import sys
import os
import gettext
import argparse
import json
import re

from cydc_txt_compress import CydcTextCompressor, NUM_TOKENS
from cydc_parser import CydcParser
from cydc_codegen import CydcCodegen
from cydc_font import CydcFont

from cyd import get_asm_plus3
from cydc_utils import make_plus3_dsk


def dir_path(string):
    """_summary_

    Args:
        string (_type_): _description_

    Raises:
        NotADirectoryError: _description_

    Returns:
        _type_: _description_
    """
    if os.path.isdir(string):
        return string
    else:
        raise NotADirectoryError(string)


def file_path(string):
    """_summary_

    Args:
        string (_type_): _description_

    Raises:
        FileNotFoundError: _description_

    Returns:
        _type_: _description_
    """
    if os.path.isfile(string):
        return string
    else:
        raise FileNotFoundError(string)


def main():
    """Main function"""

    version = "0.0.3"
    program = "Choose Your Destiny Compiler " + version
    exec = "cydc"

    gettext.bindtextdomain(
        exec, os.path.join(os.path.abspath(os.path.dirname(__file__)), "locale")
    )
    gettext.textdomain(exec)
    _ = gettext.gettext

    arg_parser = argparse.ArgumentParser(sys.argv[0], description=program)

    arg_parser.add_argument(
        "-l",
        "--min-length",
        metavar=_("MIN_LENGTH"),
        type=int,
        help=_("minimum abbreviation length (default: %(default)d)"),
        default=3,
    )
    arg_parser.add_argument(
        "-L",
        "--max-length",
        metavar=_("MAX_LENGTH"),
        type=int,
        help=_("maximum abbreviation length (default: %(default)d)"),
        default=30,
    )
    arg_parser.add_argument(
        "-s",
        "--superset-limit",
        metavar=_("SUPERSET_LIMIT"),
        type=int,
        help=_("limit for the superset search heuristic (default: %(default)d)"),
        default=100,
    )
    # token_group = arg_parser.add_mutually_exclusive_group()
    arg_parser.add_argument(
        "-T",
        "--export-tokens-file",
        metavar=_("EXPORT-TOKENS_FILE"),
        help=_("file to export the found tokens"),
    )
    arg_parser.add_argument(
        "-t",
        "--import-tokens-file",
        metavar=_("IMPORT-TOKENS-FILE"),
        help=_("file with the tokens to use"),
    )
    ###
    arg_parser.add_argument(
        "-C",
        "--export-charset",
        metavar=_("EXPORT-CHARSET"),
        help=_("file to export the current character set"),
    )
    arg_parser.add_argument(
        "-c",
        "--import-charset",
        metavar=_("IMPORT-CHARSET"),
        help=_("file with the character set to use"),
    )
    ###
    arg_parser.add_argument(
        "-S",
        "--slice-texts",
        action="store_true",
        default=False,
        help=_("The text string will be sliced between two banks"),
    )
    arg_parser.add_argument(
        "-n",
        "--name",
        metavar=_("NAME"),
        help=_("Name of the output file"),
    )
    arg_parser.add_argument(
        "-x",
        "--export-json",
        action="store_true",
        help=_("Export a JSON file"),
    )
    #####################################
    arg_parser.add_argument(
        "-csc",
        "--csc-images-path",
        type=dir_path,
        help=_("path to the directory with the CSC compressed Spectrum screens"),
    )
    arg_parser.add_argument(
        "-trk",
        "--tracks-path",
        type=dir_path,
        help=_("path to the directory with the PT3 tracks"),
    )
    arg_parser.add_argument(
        "-sfx",
        "--sfx-asm-file",
        type=file_path,
        help=_("path to the asm file generated by beepfx"),
    )
    ###
    arg_parser.add_argument(
        "-v", "--verbose", action="store_true", help=_("show additional information")
    )
    arg_parser.add_argument(
        "-V",
        "--version",
        action="version",
        version=program,
        help=_("show program's version number and exit"),
    )
    #####################################################
    arg_parser.add_argument(
        "model",
        default="plus3",
        choices=["48", "128", "plus3"],
        help=_("Model of spectrum to target"),
        type=str.lower,
    )
    arg_parser.add_argument(
        "input",
        metavar=_("input.txt"),
        type=file_path,
        help=_("input filename, the script for the adventure"),
    )
    arg_parser.add_argument(
        "sjasmplus_path",
        default="sjasmplus",
        metavar=_("SJASMPLUS_PATH"),
        type=file_path,
        help=_("path to sjasmplus executable"),
    )
    arg_parser.add_argument(
        "zx0_path",
        default="zx0",
        metavar=_("ZX0_PATH"),
        type=file_path,
        help=_("path to zx0 executable"),
    )
    arg_parser.add_argument(
        "mkp3fs_path",
        default="mkp3fs",
        type=file_path,
        metavar=_("MKP3FS_PATH"),
        help=_("path to mkp3fs executable"),
    )
    arg_parser.add_argument(
        "output_path",
        default=".",
        type=dir_path,
        metavar=_("OUTPUT_PATH"),
        help=_("Output path to files"),
    )

    args = arg_parser.parse_args()

    verbose = args.verbose
    model = args.model
    output_name = args.name

    if model != "plus3":
        sys.exit("ERROR: model not yet supported")

    if sys.version_info[0] < 3:  # Python 2
        sys.exit(_("ERROR: Invalid python version"))

    if not os.path.isfile(args.input):
        sys.exit(_("ERROR: Path to input file does not exist."))

    with open(args.input, "r", encoding="utf-8") as f:
        text = f.read()

    if output_name is None:
        output_name = os.path.splitext(os.path.basename(args.input))
        output_name = output_name[0]

    ######################################################################
    tokens = None
    if args.import_tokens_file is not None:
        input_token_file = args.import_tokens_file
        if not os.path.isfile(input_token_file):
            sys.exit(_("Path to token file does not exist."))
        with open(input_token_file, "r", encoding="utf-8") as fti:
            try:
                jsonToken = json.load(fti)
            except json.JSONDecodeError:
                sys.exit(_("ERROR: The token import file has not a valid format."))
            if not isinstance(jsonToken, list):
                sys.exit(_("ERROR: The token import file has not a valid format."))
            if len(jsonToken) > NUM_TOKENS:
                sys.exit(
                    _(
                        "ERROR: Number of tokens must be equal o less to %(NUM_TOKENS)d."
                        % {"NUM_TOKENS": NUM_TOKENS}
                    )
                )
            for t in jsonToken:
                if not isinstance(t, str):
                    sys.exit(_("ERROR: The token import file has not a valid format."))
            tokens = jsonToken

    ######################################################################
    # Importing Font
    font = CydcFont()
    if args.import_charset is not None:
        input_charset_file = args.import_charset
        jsonCharset = None
        if not os.path.isfile(input_charset_file):
            sys.exit(_("Path to charset file does not exist."))
        with open(input_charset_file, "r", encoding="utf-8") as fci:
            try:
                jsonCharset = json.load(fci)
            except json.JSONDecodeError:
                sys.exit(_("ERROR: The charset import file has not a valid format."))
            if not isinstance(jsonCharset, list):
                sys.exit(_("ERROR: The charset import file has not a valid format."))
            if len(jsonCharset) > 256:
                sys.exit(_("ERROR: Too many characters!"))
            for c in jsonCharset:
                if not isinstance(c, dict):
                    sys.exit(
                        _("ERROR: The charset import file has not a valid format.")
                    )
                if set(c.keys()) != set(["Character", "Width"]):
                    sys.exit(
                        _("ERROR: The charset import file has not a valid format.")
                    )
                pxl = c["Character"]
                if len(pxl) != 8:
                    sys.exit(
                        _("ERROR: The charset import file has not a valid format.")
                    )
                for l in pxl:
                    if not isinstance(l, int):
                        sys.exit(
                            _("ERROR: The charset import file has not a valid format.")
                        )
                    if l < 0 or l > 255:
                        sys.exit(
                            _("ERROR: The charset import file has not a valid format.")
                        )
                w = c["Width"]
                if not isinstance(w, int):
                    sys.exit(
                        _("ERROR: The charset import file has not a valid format.")
                    )
                if w < 1 or w > 8:
                    sys.exit(
                        _("ERROR: The charset import file has not a valid format.")
                    )
        font.loadCharset(jsonCharset)

    ######################################################################
    if verbose:
        print(_("Parsing code..."))

    parser = CydcParser()
    parser.build()
    # parser.lexer.test(text)
    code = parser.parse(text)
    if len(parser.errors) > 0:
        for e in parser.errors:
            print("ERROR:" + e)
        sys.exit(1)

    ######################################################################

    if verbose:
        print(_("Compressing texts..."))

    # Recollecting strings for tokenization
    strings = []
    positions = []
    for pos, value in enumerate(code):
        opcode = value[0]
        if opcode == "TEXT":
            text = value[1]
            strings.append(text)
            positions.append(pos)

    txtComp = CydcTextCompressor(gettext, args.superset_limit, verbose)
    (textBytes, tokenBytes, tokens) = txtComp.compress(
        strings, args.min_length, args.max_length, tokens
    )

    # Exporting tokens
    if args.export_tokens_file is not None:
        output_token_file = args.export_tokens_file
        with open(output_token_file, "w", encoding="utf-8") as fto:
            fto.write(json.dumps(tokens))

    # Set text to compressed bytes format
    for posT, posC in enumerate(positions):
        code[posC] = ("TEXT", textBytes[posT])

    del txtComp
    ######################################################################

    # Exporting current font
    if args.export_charset is not None:
        output_charset_file = args.export_charset
        with open(output_charset_file, "w", encoding="utf-8") as fco:
            fco.write(font.getJson())

    ######################################################################
    if verbose:
        print(_("Reading external files..."))

    sfx = None
    if args.sfx_asm_file is not None:
        with open(args.sfx_asm_file, "r", encoding="utf-8") as f:
            sfx = f.read()
            sfx = re.sub("org\s+\d{1,6}", "", sfx, flags=re.IGNORECASE)

    blocks = []
    if args.csc_images_path is not None:
        for i in range(256):
            fpath = os.path.join(args.csc_images_path, f"{i:03d}.CSC")
            if os.path.isfile(fpath):
                with open(fpath, "rb") as f:
                    b = list(f.read())
                    t = ("SCR", i, len(b), b, fpath)
                    blocks.append(t)

    if args.tracks_path is not None:
        for i in range(256):
            fpath = os.path.join(args.tracks_path, f"{i:03d}.PT3")
            if os.path.isfile(fpath):
                with open(fpath, "rb") as f:
                    b = list(f.read())
                    t = ("TRK", i, len(b), b, fpath)
                    blocks.append(t)

    ######################################################################

    if verbose:
        print(_("Generating final bytecode..."))

    codegen = CydcCodegen(gettext)

    if model == "plus3":
        code_dsk = codegen.generate_code_dsk(
            code=code, tokens=tokenBytes, font=font, slice_text=args.slice_texts
        )
        for p, i in enumerate(code_dsk):
            if i > 255:
                sys.exit(_(f"ERROR: Invalid character.{i} - {chr(i)} at {p} byte."))

        try:
            filename = os.path.join(args.output_path, "SCRIPT.DAT")
            with open(filename, "wb") as f:
                fileBytes = bytes(code_dsk)
                f.write(fileBytes)
        except OSError:
            sys.exit(_("ERROR: Can't write SCRIPT.DAT file."))

    if args.export_json:
        code_out = codegen.generate_code(
            code=code, tokens=tokenBytes, font=font, slice_text=args.slice_texts
        )
        try:
            with open(
                os.path.join(args.output_path, output_name + ".json"),
                "w",
                encoding="utf-8",
            ) as fe:
                fe.write(json.dumps(code_out))
        except OSError:
            sys.exit(_("ERROR: Can't write destination JSON file."))
    ######################################################################
    if verbose:
        print(_("Assembling interpreter..."))

    try:
        if model == "plus3":
            get_asm_plus3(
                sjasmplus_path=args.sjasmplus_path,
                output_path=args.output_path,
                sfx_asm=sfx,
                filename_script="SCRIPT.DAT",
            )
    except OSError:
        sys.exit(_("ERROR: Error assembling interpreter."))

    ######################################################################
    if model == "plus3":
        if verbose:
            print(_("Assembling disk..."))
        files = [
            os.path.join(args.output_path, "DISK"),
            os.path.join(args.output_path, "CYD.BIN"),
            os.path.join(args.output_path, "SCRIPT.DAT"),
        ]
        for b in blocks:
            btype = b[0]
            bpath = b[4]
            if btype == "SCR" or btype == "TRK":
                files.append(bpath)
        try:
            make_plus3_dsk(
                args.mkp3fs_path,
                os.path.join(args.output_path, output_name + ".DSK"),
                output_name,
                files,
            )
        except OSError:
            sys.exit("ERROR: could not create DSK file")

    ######################################################################
    sys.exit(0)


if __name__ == "__main__":
    main()
